## 并发与并行区别

并发：并发执行在宏观是同时进行的，但在微观上仍然是顺序执行的（时间片轮转控制）

并行：通过开启一个线程来真正地同时执行多个任务



## 为什么要划分用户态和系统态（核心态）

把用户程序和系统程序区分开来，以利于程序的**共享和保护**



## 第3章 程序、进程、线程



### 进程

进程的静态描述： 进程控制块（**PCB**），程序段，数据结构集（程序段要操作的数据）

#### 进程的特性：

- **动态性**：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。
- **并发性**：任何进程都可以同其他进程一起并发执行
- **独立性**：进程是一个能独立运行的基本单位，同时也是**系统分配资源和调度的独立单位；**
- **异步性**：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度

#### PCB

- 由于PCB是系统感知进程的唯一实体，所有PCB都是全部or部分常驻内存的
- PCB包含一个进程的**描述信息、控制信息、资源信息**

1. 描述信息包含 **进程名**（Pid）、**用户名**（进程所属哪个用户）、**家族关系**（父子进程）  
2. 控制信息包含 **进程的当前状态**、**进程优先级**、**程序的开始地址**、各种计时信息（占用资源的情况）、通信信息（与别的进程的交互情况）
3. 资源管理信息
4. CPU现场保护结构： 进程发生等待时，**为了能在被打断处恢复运行**，需要保护当前进程的CPU现场。

扫盲（进程的5个状态）：初始、就绪、执行、等待、终止状态



#### 进程上下文

- 上文：**已经执行过**的进程**指令和数据**在相关**寄存器和堆栈**中的内容
- 正文：执行时
- 下文：待执行



#### 进程上下文切换

进程上下文切换发生在**不同**的进程之间， 一般包含 **3**个部分，并涉及**3个**进程

如下图所示

<img src="C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\进程上下文切换.jpg" alt="上下文切换" style="zoom:10%;" />

进程上下文切换涉及到**系统调度**和**分配程序**，因此**比较耗费时间**



#### 进程状态

等待状态：进程因等待某种事情发生而处于等待状态

就绪状态：处于等待状态的进程**被唤醒**后， 但没有得到**处理机**而进入**就绪状态**

**结论**：就绪状态缺少的运行条件 比 等待状态少。  

<img src="C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\进程状态转换.jpg" alt="进程状态转换" style="zoom:15%;" />





#### 原语

原语：**系统态**下执行的某些特定功能的程序段。  分为**机器指令级**原语和**功能级**原语

- 机器指令级原语：执行期间不允许中断
- 功能级原语：特点是 作为原语的程序段不允许并发执行

**思考？  这两个感觉描述是一样的啊**



#### 进程的创建

创建方式有两种： **都必须调用创建原语来实现**。   并且两种方式都必须由**操作系统**创建一部分承担系统资源分配和管理工作的系统进程

- 由系统程序模块统一创建（进程之间是**平等**关系，**无**资源继承关系）
- 由父进程创建（**隶属**关系，形成**家族**关系， 可以继承父进程所拥有的资源）



#### 进程的撤销

发生进程撤销的情况：

1. 进程完成功能而**正常终止**
2. 发生某种错误而**非正常终止**
3. 祖先进程要求撤销某个紫禁城

进程创建和撤销流程如下图：

<img src="C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\进程创建和撤销.jpg" style="zoom:15%;" />

#### 进程的唤醒

唤醒进程的方法：

1. 有系统进程唤醒
2. 由事件发生进程唤醒

阻塞原语和唤醒原语，如图所示



#### 临界区

临界区：不允许多个并发进程**交叉执行**的一段程序。（也可以成为**访问公用数据*的那一段程序）



#### 信号量

semaphore**大于等于0**表示 可用并发进程使用的资源实体数， **<0代表正在等待使用临界区的进程数**

- P、V原语是用来操作信号量的数值的。 （**P减、V增**）

P、V原语操作图，如下



#### 进程同步

概念扫盲：

- 并发进程的直接制约： 一组在异步环境下的并发进程，各自的**执行结果互为对方的执行条件**，从而限制各进程的执行速度的过程
- 进程间的同步： 一组异步环境下的并发进程因直接制约而互相发送消息而进行相互合作、互相等待，使得各进程按一定的速度执行的过程。   
- 合作进程： 具有同步关系的一组并发进程
- 消息或事件：合作进程间互相发送的信号



Vs 进程互斥： 进程互斥是的进程执行顺序是可以**任意**的



私用信号量Vs公用信号量：

- 私用信号量： 用在进程同步的，  这里的信号量只和**制约进程**和**被制约进程**有关，而不是和整组并发进程有关
- 公用信号量： 用在进程互斥



#### 生产者-消费者问题（多对多）

该问题是一个同步问题，满足如下条件：

- 消费者想要接受数据，有界缓冲区至少有一个单元是满的
- 生产者想要发送数据，有界缓冲区至少有一个单元是空的

临界缓冲区是一个临界资源， 因此生产者和消费者必须**互斥**执行



#### 进程通信

进程通信意味着在进程间**传送数据**

1. 管道（有名管道和无名管道）

无名管道为建立管道的进程及其子孙提供一条以**比特流**传送消息的通信管道。

- 逻辑上 是 管道文件
- 物理上是有 文件系统的高速缓冲区构成。



过程：

- 发送进程利用文件系统的系统调用 ``` write(fd[1], buf,size)```把``` buf```中长度为```size```个字符的消息送入管道```fd[1]```
- 接受进程使用系统调用```read(fd[0],buf,size)```从管道出口```fd[0]```读出```size```个字符消息置入```buf```中

```c
//利用系统调用pipe可建立一条同步通信管道
int fd[2]
pipe(fd)
```







#### 死锁（非常重要）

死锁定义：指各个并发互相等待对方所拥有的资源，并且这些并发进程在得到对方的资源之前不会释放自己所拥有的的资源。

从死锁定义中就可以看出， 产生死锁的四大必要条件：

- 互斥条件： 即共享资源是不能不两个以上的进程使用的。
- 不剥夺条件： 进程多获的资源在未使用完成前，是不能被其他进程强行剥夺的
- 请求与保持： 等待所需资源的同时，是不会放弃已拥有的资源的
- 循环等待： 产生一个环， 环中的**每一个进程**所拥有的资源同时被下一个进程所请求。



#### 死锁的消除方法

方法分为： 预防、避免、检测与恢复  3种。

- 预防： 1. 打破资源的互斥。 允许进程同时访问某些资源      2.打破请求与保持这个条件，  预先分配各个并发进程所需要的全部资源。3. 打破循环等待条件：把资源按书序排列，使进程在申请、保持资源是不形成环路。

上述2方法缺点：

1. 一个进程执行前，通常不知道其所需要的全部资源
2. 一个进程只有全部的资源满足了， 该进程才会执行。
3. 对不经常使用的资源， 进程在生存期间一直占用他们是一种浪费
4. 降低了进程的并发性

- 死锁避免
- 死锁的检测和恢复：  1. 检测： 有限状态转移图 和 PrtriNet可以判断死锁发生   
  2. 恢复：
     - 终止各个锁住进程
     - 按一定顺序终止进程序列，直到已释放到有足够资源来完成剩下的进程
     - 从被锁住进程中 强行剥夺资源以解除死锁



### 线程

进程拥有一个完整的虚拟地址空间

进程不依赖与线程，是独立存在的

线程有TCB，这个保存的信息主要是相关指针 **堆栈以及寄存器**中的状态数据



某个线程阻塞可能导致该线程所属的进程被阻塞

线程的状态转换图如下







## 第4 章 处理机调度

#### 作业概念扫盲

在一次应用业务处理中，从输入开始到输出结束，用户要求计算机所做的有关该次业务处理的全部工位



#### 作业Vs进程

- 作业是用户向计算机提交任务的**任务实体**
- 进程则是九三级为了完成用户任务而设置的**执行实体**，是**系统分配资源的基本单位**
- 要完成一个任务实体，必须要有一个以上的执行实体。  即一个作业总是由一个以上的进程组成。



#### 处理机调度可分为4级

- 作业调度（宏观调度）：对**外存输入井的作业**进行选择，给选出的作业**分配内存和输入输出设备等资源**，并**建立相应的根进程**，使得该作业的进程获得竞争处理机的权利
- 交换调度（中级调度）： **内存和外存作业的调度**。  将外存中处理就绪状态或等待状态的进程调入内存。    将内存中处于就绪状态或等待状态的进程交换到外存。
- 进程调度（微观调度）： 选取一个处于就绪状态的进程占用处理机
- 线程调度。



作业的状态及其转换，如下图所示

<img src="C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\作业状态转换.jpg" style="zoom:10%;" />



### 作业调度

作业调度作用： 完成作业从后备状态到执行状态的转变， 以及从执行状态到完成状态的转变

#### 作业控制块

作业控制块（JCB）包含 作业名、作业类型、资源要求、资源使用情况、优先级、当前状态、其他

系统在作业进入后备状态时，为改作业建立它的```JCB```。 而当该作业执行完毕进入到完成状态后，系统又撤销其JCB而释放有关资源并撤销改作业

作业调度状态的转换过程，如下图所示

<img src="C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\作业调度状态转换.jpg" style="zoom:15%;" />



### 进程调度

#### 调度算法

1. 先来先服务（调度对象为**作业or进程**）---- FCFS（First Come First Serve）

将用户作业和就绪进程按**提交顺序or变为就绪状态的先后**排成队列， 按照先来先服务的方式进行调度处理

缺点： 对那些短任务或进程来说，要是排在长任务or进程后面，  他们的周转时间会比较长

周转时间 = 完成时间 - 提交时间

2. 轮转法（round robin）---调度对象：进程

原理： 将CPU的处理时间分为固定大小的**时间片**。

过程： 一个进程（**就绪队列队首**）在被调度之后用完了系统规定的时间片,但未完成任务， 则它会**释放**自己所占有的**CPU**并且排到**就绪队列的队尾**

从原理和过程中可以看出，这个方法只能用来调度那些可以**抢占**的资源

- CPU是可抢占资源，打印机资源是不可抢占的。  
- 作业调度是对除了CPU之外的所有系统硬件资源的分配，其中包含了不可抢占资源，所以**作业调度不用轮转法**



时间片长度Q的选择很重要：

- 过短， 频繁的进程上下文切换次数增加，加大系统开销
- 过长， 太长就变成了了FCFS

```C
Q = R / Nmax
R:系统对响应时间的要求
Nmax:就绪队列中所允许的最大进程数
```

3. 多级反馈轮转法（round robin with mutiple feedback）  **调度对象进程**

轮转法中，进程加入到就绪队列的情况：

- 改进程的时间片用完，当该进程还没完成
- 该进程的时间片未用完，但被I/O请求阻塞了。 当阻塞解除后，再回到就绪队列
- 新创建的进程进入就绪队列

思想： 对这3中进程区别对待， 分别给予不同的优先级和时间片

过程：

- 根据进程到达就绪队列的类型 or 进程被阻塞的原因分成不同的就绪队列。

- 每个队列的优先级相同，按FCFS的原则进行排列



4. 优先级法（调度对象：**作业 or 进程**）

确定进程or作业优先级：

- 静态优先级（作业紧急程度，作业类型，进程类型)
- 动态优先级

#### 动态优先级

- 根据进程**占有CPU时间的长短**来决定。  **反比关系**。  一个进程这次占有CPU的时间**越长**，下一次被调度的优先级就**越低**
- 根据**就绪进程**等待CPU的时间长短来决定。   **正比关系**。



5. 最短作业优先法（Shorest Job First） SJF

最短作业优先法就是选择那些估计需要执行时间最短的作业来执行。

缺点： 对于一个不断有作业进入的批处理系统， SJF可能使长作业永远得不到调度执行的机会。



6. 最高响应比优先法（Highest Response-ratio Next）  **调度对象**：作业和进程

这是对 FCFS 和 SJF的一个综合。

- FCFS只考虑每个作业的等待时间
- SJF只考虑每个作业的执行时间

这个方法，同时考虑**等待时间**和**执行时间**

```Java
响应比公式：
R = (W + T) / T = 1 + W / T;
//T:该作业or 进程的执行时间
//W:作业or进程 在后备状态队列中的的等待时间
```



## 第5章 存储管理

**地址重定位or地址映射**：把虚拟空间中已链接和划分好的内容装入内存，并将**虚拟地址**  映射 为**内存地址**。

有两种方法： 静态地址重定位、 动态地址重定位



1. 静态地址重定位

优点：

- 不需要硬件支持

缺点：

- 无法实现虚拟存储器
- 必须占用连续的内存空间，难以做到程序和数据的共享

2. 动态地址重定位： 在程序的执行过程中，在CPU访问内存之前，将要访问的程序或数据地址转换成内存地址。  依靠硬件地址变换机构完成。

```Java
//指令或数据的内存地址MA 与 虚拟地址的关系
MA = (BR) + (VR)
/**
 BR: 基地址寄存器
 VR: 虚拟地址寄存器
*/
```

优点：

- 可以对内存进行非连续分配
- 动态重定位提供了实现虚拟器存储器的基础
- 利于程序段的共享





### 5.2 分区存储管理

1. **固定分区法**

- 固定分区法就是把内存**固定地**划分为若干个大小不等的区域
- 系统通过**分区说明表**管理和控制内存
- 分区说明表： 有 各分区区号、分区大小、起始地址、是否空闲区

缺点： 即使是小作业也可能要占用大分区的现象， 内存利用率低



2. 动态分区法

P107



#### 分区的分配和挥挥手

1. 固定分区法   见P109
2. 动态分区法

动态分区时分配与回收要解决的3个问题

- 对于请求表中的要求内存长度，从可用表或自由链中寻找出合适的空闲区分配程序
- 分配空间区后，要**更新可用表 or 自由链**
- 进程or作业 释放内存资源是，要和相邻的空闲区进行**合并**， 并且**更新可用表 or 自由链**

寻找空闲区有3中算法

1. 最先适应算法： 可用表 or 自由链 按**起始地址递增的顺序**排序， 遇到**第一个**符合的就分配，并且更新可用表or自由链。
2. 最佳适应算法：按照可用分区的长度**大小**  **递增**的顺序排序， 然后同上。
3. 最坏适应算法： 与上面相反，按分区大小递减排序，然后同上。

最佳和最坏： 因为涉及到排序问题， 在更新可用表时， 因为可用分区的大小发生了改变，因此也必须调整改分区的位置。



### 5.4 页式管理

进程的虚拟地址变为页号P与页内地址W组成。  例如一个页长10K，拥有1024页的虚拟空间地址结构如图所示

![](C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\页的划分.jpg)

- 页号对应有多少页
- 页内地址对应页的长度

页式管理的优点：

- 实现了内存中碎片的减少。
- 实现了由连续存储到非连续存储的质的飞跃。
- 
## 并发与并行区别

并发：并发执行在宏观是同时进行的，但在微观上仍然是顺序执行的（时间片轮转控制）

并行：通过开启一个线程来真正地同时执行多个任务



## 为什么要划分用户态和系统态（核心态）

把用户程序和系统程序区分开来，以利于程序的**共享和保护**



## 程序、进程、线程



### 进程

进程的静态描述： 进程控制块（**PCB**），程序段，数据结构集（程序段要操作的数据）

#### 进程的特性：

- **动态性**：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。
- **并发性**：任何进程都可以同其他进程一起并发执行
- **独立性**：进程是一个能独立运行的基本单位，同时也是**系统分配资源和调度的独立单位；**
- **异步性**：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度

#### PCB

- 由于PCB是系统感知进程的唯一实体，所有PCB都是全部or部分常驻内存的
- PCB包含一个进程的**描述信息、控制信息、资源信息**

1. 描述信息包含 **进程名**（Pid）、**用户名**（进程所属哪个用户）、**家族关系**（父子进程）  
2. 控制信息包含 **进程的当前状态**、**进程优先级**、**程序的开始地址**、各种计时信息（占用资源的情况）、通信信息（与别的进程的交互情况）
3. 资源管理信息
4. CPU现场保护结构： 进程发生等待时，**为了能在被打断处恢复运行**，需要保护当前进程的CPU现场。

扫盲（进程的5个状态）：初始、就绪、执行、等待、终止状态



#### 进程上下文

- 上文：**已经执行过**的进程**指令和数据**在相关**寄存器和堆栈**中的内容成文上文
- 正文：执行时
- 下文：待执行



#### 进程上下文切换

进程上下文切换发生在**不同**的进程之间， 一般包含 **3**个部分，并涉及**3个**进程

如下图所示

<img src="C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\进程上下文切换.jpg" alt="上下文切换" style="zoom:10%;" />

进程上下文切换涉及到**系统调度**和**分配程序**，因此**比较耗费时间**



#### 进程状态

等待状态：进程因等待某种事情发生而处于等待状态

就绪状态：处于等待状态的进程**被唤醒**后， 但没有得到**处理机**而进入**就绪状态**

**结论**：就绪状态缺少的运行条件 比 等待状态少。  

<img src="C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\进程状态转换.jpg" alt="进程状态转换" style="zoom:15%;" />





#### 原语

原语：**系统态**下执行的某些特定功能的程序段。  分为**机器指令级**原语和**功能级**原语

- 机器指令级原语：执行期间不允许中断
- 功能级原语：特点是 作为原语的程序段不允许并发执行

**思考？  这两个感觉描述是一样的啊**



#### 进程的创建

创建方式有两种： **都必须调用创建原语来实现**。   并且两种方式都必须由**操作系统**创建一部分承担系统资源分配和管理工作的系统进程

- 由系统程序模块统一创建（进程之间是**平等**关系，**无**资源继承关系）
- 由父进程创建（**隶属**关系，形成**家族**关系， 可以继承父进程所拥有的资源）



#### 进程的撤销

发生进程撤销的情况：

1. 进程完成功能而**正常终止**
2. 发生某种错误而**非正常终止**
3. 祖先进程要求撤销某个紫禁城

进程创建和撤销流程如下图：

<img src="C:\Users\86177\Desktop\秋招准备\prepareForInterview\Ysoretarted\src\main\java\com\zju\图片\进程创建和撤销.jpg" style="zoom:15%;" />

#### 进程的唤醒

唤醒进程的方法：

1. 有系统进程唤醒
2. 由事件发生进程唤醒

阻塞原语和唤醒原语，如图所示



#### 临界区

临界区：不允许多个并发进程**交叉执行**的一段程序。（也可以成为**访问公用数据*的那一段程序）



#### 信号量

semaphore**大于等于0**表示 可用并发进程使用的资源实体数， **<0代表正在等待使用临界区的进程数**

- P、V原语是用来操作信号量的数值的。 （**P减、V增**）

P、V原语操作图，如下



#### 进程同步

概念扫盲：

- 并发进程的直接制约： 一组在异步环境下的并发进程，各自的**执行结果互为对方的执行条件**，从而限制各进程的执行速度的过程
- 进程间的同步： 一组异步环境下的并发进程因直接制约而互相发送消息而进行相互合作、互相等待，使得各进程按一定的速度执行的过程。   
- 合作进程： 具有同步关系的一组并发进程
- 消息或事件：合作进程间互相发送的信号



Vs 进程互斥： 进程互斥是的进程执行顺序是可以**任意**的



私用信号量Vs公用信号量：

- 私用信号量： 用在进程同步的，  这里的信号量只和**制约进程**和**被制约进程**有关，而不是和整组并发进程有关
- 公用信号量： 用在进程互斥



#### 生产者-消费者问题（多对多）

该问题是一个同步问题，满足如下条件：

- 消费者想要接受数据，有界缓冲区至少有一个单元是满的
- 生产者想要发送数据，有界缓冲区至少有一个单元是空的

临界缓冲区是一个临界资源， 因此生产者和消费者必须**互斥**执行



#### 进程通信

进程通信意味着在进程间**传送数据**

1. 管道（有名管道和无名管道）

无名管道为建立管道的进程及其子孙提供一条以**比特流**传送消息的通信管道。

- 逻辑上 是 管道文件
- 物理上是有 文件系统的高速缓冲区构成。



过程：

- 发送进程利用文件系统的系统调用 ``` write(fd[1], buf,size)```把``` buf```中长度为```size```个字符的消息送入管道```fd[1]```
- 接受进程使用系统调用```read(fd[0],buf,size)```从管道出口```fd[0]```读出```size```个字符消息置入```buf```中

```c
//利用系统调用pipe可建立一条同步通信管道
int fd[2]
pipe(fd)
```







#### 死锁（非常重要）

死锁定义：指各个并发互相等待对方所拥有的资源，并且这些并发进程在得到对方的资源之前不会释放自己所拥有的的资源。

从死锁定义中就可以看出， 产生死锁的四大必要条件：

- 互斥条件： 即共享资源是不能不两个以上的进程使用的。
- 不剥夺条件： 进程多获的资源在未使用完成前，是不能被其他进程强行剥夺的
- 请求与保持： 等待所需资源的同时，是不会放弃已拥有的资源的
- 循环等待： 产生一个环， 环中的**每一个进程**所拥有的资源同时被下一个进程所请求。



#### 死锁的消除方法

方法分为： 预防、避免、检测与恢复  3种。

- 预防： 1. 打破资源的互斥。 允许进程同时访问某些资源      2.打破请求与保持这个条件，  预先分配各个并发进程所需要的全部资源。3. 打破循环等待条件：把资源按书序排列，使进程在申请、保持资源是不形成环路。

上述2方法缺点：

1. 一个进程执行前，通常不知道其所需要的全部资源
2. 一个进程只有全部的资源满足了， 该进程才会执行。
3. 对不经常使用的资源， 进程在生存期间一直占用他们是一种浪费
4. 降低了进程的并发性

- 死锁避免
- 死锁的检测和恢复：  1. 检测： 有限状态转移图 和 PrtriNet可以判断死锁发生   
  2. 恢复：
     - 终止各个锁住进程
     - 按一定顺序终止进程序列，直到已释放到有足够资源来完成剩下的进程
     - 从被锁住进程中 强行剥夺资源以解除死锁



### 线程

进程拥有一个完整的虚拟地址空间

进程不依赖与线程，是独立存在的

线程有TCB，这个保存的信息主要是相关指针 **堆栈以及寄存器**中的状态数据



某个线程阻塞可能导致该线程所属的进程被阻塞

线程的状态转换图如下

